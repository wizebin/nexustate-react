!function(e,n){"object"==typeof exports&&"object"==typeof module?module.exports=n():"function"==typeof define&&define.amd?define("nexusdk",[],n):"object"==typeof exports?exports.nexusdk=n():e.nexusdk=n()}(global,function(){return function(e){var n={};function t(r){if(n[r])return n[r].exports;var a=n[r]={i:r,l:!1,exports:{}};return e[r].call(a.exports,a,a.exports,t),a.l=!0,a.exports}return t.m=e,t.c=n,t.d=function(e,n,r){t.o(e,n)||Object.defineProperty(e,n,{enumerable:!0,get:r})},t.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},t.t=function(e,n){if(1&n&&(e=t(e)),8&n)return e;if(4&n&&"object"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(t.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:e}),2&n&&"string"!=typeof e)for(var a in e)t.d(r,a,function(n){return e[n]}.bind(null,a));return r},t.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(n,"a",n),n},t.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},t.p="",t(t.s=4)}([function(module,exports,__webpack_require__){var factory;global,factory=function(){return function(e){var n={};function t(r){if(n[r])return n[r].exports;var a=n[r]={i:r,l:!1,exports:{}};return e[r].call(a.exports,a,a.exports,t),a.l=!0,a.exports}return t.m=e,t.c=n,t.d=function(e,n,r){t.o(e,n)||Object.defineProperty(e,n,{enumerable:!0,get:r})},t.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},t.t=function(e,n){if(1&n&&(e=t(e)),8&n)return e;if(4&n&&"object"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(t.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:e}),2&n&&"string"!=typeof e)for(var a in e)t.d(r,a,function(n){return e[n]}.bind(null,a));return r},t.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(n,"a",n),n},t.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},t.p="",t(t.s="./src/index.js")}({"./node_modules/objer/dist/src/index.js":
/*!**********************************************!*\
  !*** ./node_modules/objer/dist/src/index.js ***!
  \**********************************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval("(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory();\n\telse {}\n})(global, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// object to store loaded and loading wasm modules\n/******/ \tvar installedWasmModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__webpack_require__.r = function(exports) {\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// object with all compiled WebAssembly.Modules\n/******/ \t__webpack_require__.w = {};\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = \"./src/index.js\");\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ \"./src/index.js\":\n/*!**********************!*\\\n  !*** ./src/index.js ***!\n  \\**********************/\n/*! exports provided: set, keys, values, has, hasRoot, get, getObjectPath, getStringPathForArray, assurePathExists, getTypeString, deepEq, shallowDiff, default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"set\\\", function() { return set; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"keys\\\", function() { return keys; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"values\\\", function() { return values; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"has\\\", function() { return has; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"hasRoot\\\", function() { return hasRoot; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"get\\\", function() { return get; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"getObjectPath\\\", function() { return getObjectPath; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"getStringPathForArray\\\", function() { return getStringPathForArray; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"assurePathExists\\\", function() { return assurePathExists; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"getTypeString\\\", function() { return getTypeString; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"deepEq\\\", function() { return deepEq; });\\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \\\"shallowDiff\\\", function() { return shallowDiff; });\\n/**\\n * Objer module, interact with objects\\n * @module objer\\n */\\n\\n/**\\n * Set value at an object subpath\\n * @param {Object} object\\n * @param {string|array} path\\n * @param {*} value\\n */\\nfunction set(object, path, value) {\\n  let subObject = object;\\n  const keys = getObjectPath(path);\\n  for (let keydex = 0; keydex < keys.length; keydex += 1) {\\n    let key = keys[keydex];\\n    if (key !== '') {\\n      if (keydex !== keys.length - 1) {\\n        if (subObject[key] === null || typeof subObject[key] !== 'object') {\\n          subObject[key] = {};\\n        }\\n        subObject = subObject[key];\\n      } else {\\n        subObject[key] = value;\\n      }\\n    }\\n  }\\n\\n  return object;\\n}\\n\\n/**\\n * Get array of keys in an object\\n * @param {Object} object\\n */\\nfunction keys(object) {\\n  const stringType = getTypeString(object);\\n  if (stringType === 'object') {\\n    if (typeof Object.keys !== 'undefined') return Object.keys(object);\\n    const keys = [];\\n\\n    for(let key in object) {\\n      if (object.hasOwnProperty(key)) {\\n        keys.push(key);\\n      }\\n    }\\n\\n    return keys;\\n  }\\n  return [];\\n}\\n\\n/**\\n * Get array of values in an object, passing an array will return the original array, anything else will return a blank array\\n * @param {Object} object\\n */\\nfunction values(object) {\\n  const stringType = getTypeString(object);\\n  if (stringType === 'object') {\\n    const objectKeys = keys(object);\\n    const result = [];\\n    for (let keydex = 0; keydex < objectKeys.length; keydex += 1) {\\n      result.push(object[objectKeys[keydex]]);\\n    }\\n    return result;\\n  } else if (stringType === 'array') {\\n    return object;\\n  }\\n  return [];\\n}\\n\\n/**\\n * Check if an object has a value at a path\\n * @param {Object} object\\n * @param {string|array} path\\n */\\nfunction has(object, path) {\\n  let subObject = object;\\n  const keys = getObjectPath(path);\\n  if (keys.length === 0) return false;\\n  for (let keydex = 0; keydex < keys.length; keydex += 1) {\\n    let key = keys[keydex];\\n    if (!hasRoot(subObject, key)) return false;\\n    subObject = subObject[key];\\n  }\\n\\n  return true;\\n}\\n\\n/**\\n * Check if an object has a top level key, hasRoot({ a: 1 }, 'a'); is true, hasRoot({ a: { b: 1 } }, 'a.b'); is false\\n * @param {Object} object\\n * @param {string} key\\n */\\nfunction hasRoot(object, key) {\\n  if (object !== null && typeof object === 'object') {\\n    return (key in object);\\n  }\\n  return false;\\n}\\n\\n/**\\n * Retrieve value from within an object or array\\n * @param {Object} object\\n * @param {string|array} path\\n * @param {*} [defaultValue]\\n */\\nfunction get(object, path, defaultValue = undefined) {\\n  let subObject = object;\\n  const keys = getObjectPath(path);\\n  for (let keydex = 0; keydex < keys.length; keydex += 1) {\\n    let key = keys[keydex];\\n    if (key !== '') {\\n      if (!hasRoot(subObject, key)) return defaultValue;\\n\\n      subObject = subObject[key];\\n    }\\n  }\\n\\n  return subObject;\\n}\\n\\n/**\\n * Resolve a path to a path array 'a.b.c' returns ['a', 'b', 'c']\\n * @param {string|array} path\\n */\\nfunction getObjectPath(path) {\\n  const inputType = getTypeString(path);\\n  if (inputType === 'array') return path;\\n  if (inputType !== 'string') {\\n    if (inputType === 'number') return [path];\\n    return [];\\n  }\\n  let inBrackets = false;\\n  let partBegin = 0;\\n  let split = false;\\n  let exitBrackets = false;\\n  const pathlen = path.length;\\n  const parts = [];\\n\\n  for(let dex = 0; dex < pathlen + 1; dex += 1) {\\n    const char = path[dex];\\n    if (inBrackets && !exitBrackets) {\\n      if (char === ']') {\\n        exitBrackets = true;\\n      }\\n    } else if (char === '.') {\\n      split = true;\\n    } else if (char === '[') {\\n      split = true;\\n      inBrackets = true;\\n    }\\n\\n    if (split || dex === pathlen) {\\n      let nextPart = path.substr(partBegin, dex - partBegin - (exitBrackets ? 1 : 0))\\n      if (inBrackets) {\\n        const parsed = parseInt(nextPart, 10);\\n        if (!isNaN(parsed)) {\\n          nextPart = parsed;\\n        }\\n      }\\n      parts.push(nextPart);\\n      partBegin = dex + 1;\\n      split = false;\\n      if (exitBrackets) inBrackets = false;\\n      exitBrackets = false;\\n    }\\n  }\\n  return parts;\\n}\\n\\n/**\\n * Convert an array into a string path ['a', 'b', 'c'] returns 'a.b.c'\\n * @param {array} arrayPath\\n */\\nfunction getStringPathForArray(arrayPath) {\\n  const inputType = getTypeString(arrayPath);\\n  if (inputType !== 'array') {\\n    if (inputType === 'string') return arrayPath;\\n    if (inputType === 'number') return `[${arrayPath}]`;\\n    return '';\\n  }\\n\\n  return arrayPath.reduce((result, item, dex) => {\\n    if (getTypeString(item) === 'number') {\\n      return `${result}[${item}]`;\\n    }\\n    return result + (dex > 0 ? '.': '') + item;\\n  }, '');\\n}\\n\\n/**\\n * If this subkey doesn't exist, initialize it to defaultValue\\n * @param {Object} object\\n * @param {string|array} path\\n * @param {*} defaultValue\\n */\\nfunction assurePathExists(object, path, defaultValue = {}) {\\n  const arrayPath = getObjectPath(path);\\n  let currentObject = object;\\n  for (let arraydex = 0; arraydex < arrayPath.length; arraydex += 1) {\\n    const key = arrayPath[arraydex];\\n    if (!hasRoot(currentObject, key)) { // TODO: Address problems where key exists already and is not an array or object\\n      const nextKey = ((arraydex === arrayPath.length - 1) ? null : arrayPath[arraydex + 1]);\\n      if (nextKey === null) {\\n        currentObject[key] = defaultValue;\\n      } else if (getTypeString(nextKey) === 'number') {\\n        currentObject[key] = [];\\n      } else {\\n        currentObject[key] = {};\\n      }\\n    }\\n    currentObject = currentObject[key];\\n  }\\n  return currentObject;\\n}\\n\\n/**\\n * Return simplified type as a string. [] returns 'array' new Date() returns 'date'\\n * @param {*} data\\n */\\nfunction getTypeString(data) {\\n  const stringType = typeof data;\\n  if (stringType === 'object') {\\n    if (data === null) return 'null';\\n    const stringified = toString.apply(data);\\n    if (stringified.length > 2 && stringified[0] === '[' && stringified[stringified.length - 1] === ']') {\\n      const splits = stringified.substr(1, stringified.length - 2).split(' ');\\n      if (splits.length > 1) {\\n        return splits.slice(1).join(' ').toLowerCase();\\n      }\\n    }\\n    return 'unknown';\\n  }\\n\\n  if (stringType === 'number') {\\n    if (isNaN(data)) return 'nan';\\n  }\\n\\n  return stringType;\\n}\\n\\n/**\\n * Check if both parameters are equal, check all nested keys of objects and arrays\\n * @param {*} obja\\n * @param {*} objb\\n */\\nfunction deepEq(left, right) {\\n  const leftType = getTypeString(left);\\n  const rightType = getTypeString(right);\\n\\n  if (leftType !== rightType) return false;\\n\\n  if (leftType === 'nan') return true;\\n\\n  if (leftType === 'object') {\\n    if (left === right) return true; // if they are the same thing, don't check children\\n    const leftKeys = keys(left).sort(); // unsorted could be unequal\\n    const rightKeys = keys(right).sort();\\n    if (!deepEq(leftKeys, rightKeys)) return false;\\n    for (let keydex = 0; keydex < leftKeys.length; keydex += 1) {\\n      if (!deepEq(left[leftKeys[keydex]], right[leftKeys[keydex]])) return false;\\n    }\\n    return true;\\n  }\\n  if (leftType === 'array') {\\n    if (left === right) return true; // if they are the same thing, don't check children\\n    if (left.length !== right.length) return false;\\n    for (let dex = 0; dex < left.length; dex += 1) {\\n      if (!deepEq(left[dex], right[dex])) return false;\\n    }\\n    return true;\\n  }\\n\\n  return left === right;\\n}\\n\\n/**\\n * Detect differences between two things, will indicate changes in type, value, length, etc. Will not diff string values.\\n * @param {*} original\\n * @param {*} incoming\\n */\\nfunction shallowDiff(original, incoming, currentPath = []) {\\n  let changes = [];\\n  const originalType = getTypeString(original);\\n  const incomingType = getTypeString(incoming);\\n\\n  if (originalType !== incomingType) return [{ change: 'type', path: currentPath, original: original, incoming: incoming }];\\n\\n  if (originalType === 'nan') return [];\\n\\n  if (originalType === 'object') {\\n    if (original === incoming) return []; // if they are the same thing, don't check children\\n    let originalKeys = keys(original).sort(); // unsorted could be unequal\\n    let incomingKeys = keys(incoming).sort();\\n    let sharedKeys = [];\\n    if (!deepEq(originalKeys, incomingKeys)) {\\n      for (let originalDex = originalKeys.length - 1; originalDex >= 0; originalDex -= 1) {\\n        const originalKey = originalKeys[originalDex];\\n        for (let incomingDex = incomingKeys.length - 1; incomingDex >= 0; incomingDex -= 1) {\\n          if (originalKey === incomingKeys[incomingDex]) {\\n            sharedKeys.push(originalKey);\\n            originalKeys.splice(originalDex, 1);\\n            incomingKeys.splice(incomingDex, 1);\\n            break;\\n          }\\n        }\\n      }\\n      for (let originalDex = 0; originalDex < originalKeys.length; originalDex += 1) {\\n        changes.push({ change: 'delete', path: currentPath, key: originalKeys[originalDex], original: original[originalKeys[originalDex]] });\\n      }\\n      for (let incomingDex = 0; incomingDex < incomingKeys.length; incomingDex += 1) {\\n        changes.push({ change: 'add', path: currentPath, key: incomingKeys[incomingDex], incoming: incoming[incomingKeys[incomingDex]] });\\n      }\\n    } else {\\n      sharedKeys = originalKeys;\\n    }\\n    for (let keydex = 0; keydex < sharedKeys.length; keydex += 1) {\\n      changes = changes.concat(shallowDiff(original[sharedKeys[keydex]], incoming[sharedKeys[keydex]], currentPath.concat(sharedKeys[keydex])));\\n    }\\n  } else if (originalType === 'array') {\\n    if (original === incoming) return []; // if they are the same thing, don't check children\\n    let sharedLength = original.length;\\n    if (original.length !== incoming.length) {\\n      if (original.length > incoming.length) {\\n        sharedLength = incoming.length;\\n        changes.push({ change: 'shrink', path: currentPath, original: original.slice(incoming.length) });\\n      } else {\\n        changes.push({ change: 'grow', path: currentPath, incoming: incoming.slice(original.length) });\\n      }\\n    }\\n    for (let dex = 0; dex < sharedLength; dex += 1) {\\n      changes = changes.concat(shallowDiff(original[dex], incoming[dex], currentPath.concat(dex)));\\n    }\\n  } else if (original === incoming) {\\n    return [];\\n  } else {\\n    return [{ change: 'value', path: currentPath, original, incoming }]\\n  }\\n\\n  return changes;\\n}\\n\\n/* harmony default export */ __webpack_exports__[\\\"default\\\"] = ({\\n  assurePathExists,\\n  deepEq,\\n  get,\\n  getObjectPath,\\n  getStringPathForArray,\\n  getTypeString,\\n  has,\\n  hasRoot,\\n  keys,\\n  set,\\n});\\n\\n\\n//# sourceURL=webpack://nexusdk/./src/index.js?\");\n\n/***/ })\n\n/******/ });\n});\n\n//# sourceURL=webpack://nexusdk/./node_modules/objer/dist/src/index.js?")},"./src/Nexustate.js":
/*!**************************!*\
  !*** ./src/Nexustate.js ***!
  \**************************/
/*! exports provided: getLocalStorageSaveFunc, getLocalStorageLoadFunc, default */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getLocalStorageSaveFunc", function() { return getLocalStorageSaveFunc; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getLocalStorageLoadFunc", function() { return getLocalStorageLoadFunc; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Nexustate; });\n/* harmony import */ var objer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! objer */ "./node_modules/objer/dist/src/index.js");\n/* harmony import */ var objer__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(objer__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _NexustateHelpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./NexustateHelpers */ "./src/NexustateHelpers.js");\n/* harmony import */ var _StorageManager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./StorageManager */ "./src/StorageManager.js");\n\n\n\n\nconst SAVE_THROTTLE_TIME = 100;\n\nfunction missingCallback() {\n  console.error(\'Nexustate missing saveCallback\', new Error().stack);\n}\n\nfunction getLocalStorageSaveFunc() {\n  if (typeof global !== \'undefined\' && typeof global.localStorage !== \'undefined\') {\n    return (key, data) => global.localStorage.setItem(key, JSON.stringify(data));\n  } else if (typeof window !== \'undefined\' && typeof window.localStorage !== \'undefined\') {\n    return (key, data) => window.localStorage.setItem(key, JSON.stringify(data));\n  }\n}\n\nfunction getLocalStorageLoadFunc() {\n  if (typeof global !== \'undefined\' && typeof global.localStorage !== \'undefined\') {\n    return key => JSON.parse(global.localStorage.getItem(key));\n  } else if (typeof window !== \'undefined\' && typeof window.localStorage !== \'undefined\') {\n    return key => JSON.parse(window.localStorage.getItem(key));\n  }\n}\n\nclass Nexustate {\n\n  constructor({ saveCallback = null, loadCallback = null, storageKey = \'default\', persist = false } = {}) {\n    this.setPersistenceFunctions = (save, load) => {\n      this.saveCallback = save;\n      this.loadCallback = load;\n    };\n\n    this.setPersist = shouldPersist => {\n      this.persist = shouldPersist;\n    };\n\n    this.set = (object, options = { immediatePersist: false, noNotify: false }) => {\n      const objectKeys = Object(objer__WEBPACK_IMPORTED_MODULE_0__["keys"])(object);\n      const result = [];\n      for (let keydex = 0; keydex < objectKeys.length; keydex += 1) {\n        result.push(this.setKey(objectKeys[keydex], object[objectKeys[keydex]], options));\n      }\n      return result;\n    };\n\n    this.setKey = (key, value, options = { immediatePersist: false, noNotify: false }) => {\n      const result = this.storageManager.set(key, value, options);\n      if (this.persist) this.persistData(options.immediatePersist);\n      if (!options.noNotify) this.notify({ key, value });\n      return result;\n    };\n\n    this.get = (key = null) => {\n      return this.storageManager.get(key);\n    };\n\n    this.delete = (key, options = { immediatePersist: false, noNotify: false }) => {\n      this.storageManager.delete(key);\n      if (this.persist) this.persistData(options.immediatePersist);\n      if (!options.noNotify) this.notify({ key, value: null });\n    };\n\n    this.push = (key, value, options = { immediatePersist: false, noNotify: false }) => {\n      const result = this.storageManager.push(key, value, options);\n      if (this.persist) this.persistData(options.immediatePersist);\n      if (!options.noNotify) this.notify({ key, value });\n      return result;\n    };\n\n    this.getForListener = (listener, keyChange) => {\n      const { key, alias, callback, transform } = listener;\n      const value = this.storageManager.get(key);\n\n      return { keyChange, alias, callback, key, value: transform ? transform(value) : value };\n    };\n\n    this.notifyListenerOfChange = (listener, keyChange) => {\n      const { callback } = listener;\n      callback(this.getForListener(listener, keyChange));\n    };\n\n    this.persistData = (immediate = false) => {\n      if (immediate) {\n        this.save();\n      } else {\n        this.throttledSave();\n      }\n    };\n\n    this.save = () => this.saveCallback(this.storageKey, this.storageManager.get());\n\n    this.load = () => this.storageManager.set(null, this.loadCallback(this.storageKey));\n\n    this.throttledSave = Object(_NexustateHelpers__WEBPACK_IMPORTED_MODULE_1__["throttle"])(this.save, SAVE_THROTTLE_TIME);\n\n    this.notify = ({ key, value }) => {\n      // TODO: Notify about values that are being removed\n      const keyArray = key !== null ? Object(objer__WEBPACK_IMPORTED_MODULE_0__["getObjectPath"])(key) : [];\n      const listenersWithKeys = this.recurseMatchingPathsForListeners(Object(_NexustateHelpers__WEBPACK_IMPORTED_MODULE_1__["getKeyFilledObject"])(key, value), this.listenerObject, [], keyArray.length); // this kills the specificity arrangement\n      this.batchAndNotifyOfChanges(listenersWithKeys);\n    };\n\n    this.listen = (listener = { key: null, callback: () => {}, alias: null, component: null, transform: null, noChildUpdates: false }) => {\n      const listeners = this.getListenersAtPath(listener.key);\n      const matchedListeners = listeners.reduce((results, existingListener, dex) => {\n        if (existingListener.callback === listener.callback) results.push(dex);\n        return results;\n      }, []);\n\n      for (let dex = matchedListeners.length - 1; dex >= 0; dex -= 1) {\n        listeners.splice(matchedListeners[dex], 1);\n      }\n\n      listeners.push(listener);\n      return true;\n    };\n\n    this.getListenersAtPath = key => {\n      if (key === null) return Object(objer__WEBPACK_IMPORTED_MODULE_0__["assurePathExists"])(this.listenerObject, \'listeners\', []);\n      const keyArray = Object(objer__WEBPACK_IMPORTED_MODULE_0__["getObjectPath"])(key);\n\n      let currentListenObject = this.listenerObject;\n      for (let keydex = 0; keydex < keyArray.length - 1; keydex += 1) {\n        // Go through all keys except the last, which is where out final request will go\n        const subKey = keyArray[keydex];\n        currentListenObject = Object(objer__WEBPACK_IMPORTED_MODULE_0__["assurePathExists"])(currentListenObject, [\'subkeys\', subKey], {});\n      }\n      const finalKey = keyArray[keyArray.length - 1];\n      return Object(objer__WEBPACK_IMPORTED_MODULE_0__["assurePathExists"])(currentListenObject, [\'subkeys\', finalKey, \'listeners\'], []);\n    };\n\n    this.unlisten = (key, callback) => {\n      const listeners = this.getListenersAtPath(key);\n\n      const matchedListeners = listeners.reduce((results, existingListener, dex) => {\n        if (existingListener.callback === callback) results.push(dex);\n        return results;\n      }, []);\n\n      for (let dex = matchedListeners.length - 1; dex >= 0; dex -= 1) {\n        listeners.splice(matchedListeners[dex], 1);\n      }\n    };\n\n    this.unlistenComponent = (component, basePath) => {\n      const patharray = basePath || [];\n      const subkeypath = (basePath || []).concat(\'subkeys\');\n      const subKeys = Object(objer__WEBPACK_IMPORTED_MODULE_0__["keys"])(Object(objer__WEBPACK_IMPORTED_MODULE_0__["get"])(this.listenerObject, subkeypath));\n      for (let keydex = 0; keydex < subKeys.length; keydex += 1) {\n        this.unlistenComponent(component, subkeypath.concat([subKeys[keydex]]));\n      }\n\n      const listeners = Object(objer__WEBPACK_IMPORTED_MODULE_0__["get"])(this.listenerObject, patharray.concat(\'listeners\'));\n\n      const matchedListeners = (listeners || []).reduce((results, existingListener, dex) => {\n        if (existingListener.component === component) results.push(dex);\n        return results;\n      }, []);\n\n      for (let dex = matchedListeners.length - 1; dex >= 0; dex -= 1) {\n        listeners.splice(matchedListeners[dex], 1);\n      }\n    };\n\n    this.storageManager = new _StorageManager__WEBPACK_IMPORTED_MODULE_2__["default"]();\n    this.listenerObject = { subkeys: {} };\n    this.storageKey = storageKey;\n    this.saveCallback = saveCallback || Nexustate.defaultSaveCallback;\n    this.loadCallback = loadCallback || Nexustate.defaultLoadCallback;\n    this.persist = persist;\n  }\n\n  /**\n   * Overwrites the top level values of object into the storageManager, just like react setState\n   */\n\n\n  batchAndNotifyOfChanges(changeWithListener) {\n    const result = [];\n    const callbackBatches = []; // Use this to detect multiple listeners, okay for now, need to use an object somehow in the future\n    // [{ callback: () => {}, changes: [{ getForListener() Result }]}]\n    for (let keydex = 0; keydex < changeWithListener.length; keydex += 1) {\n      const keyChange = changeWithListener[keydex];\n      const listenerIndex = Object(_NexustateHelpers__WEBPACK_IMPORTED_MODULE_1__["findIndex"])(callbackBatches, callbackBatch => callbackBatch.callback === keyChange.listener.callback);\n\n      if (listenerIndex !== -1) {\n        callbackBatches[listenerIndex].changes.push(this.getForListener(keyChange.listener, keyChange.key));\n      } else {\n        callbackBatches.push({ callback: keyChange.listener.callback, changes: [this.getForListener(keyChange.listener, keyChange.key)] });\n      }\n    }\n\n    for (let callbatch = 0; callbatch < callbackBatches.length; callbatch += 1) {\n      const listenerBatch = callbackBatches[callbatch];\n      const { callback, changes } = listenerBatch;\n\n      callback(changes);\n    }\n  }\n\n  recurseMatchingPathsForListeners(change, listenerObject, key = [], originalChangeDepth = 0, currentChangeDepth = 0) {\n    const changeRelativity = originalChangeDepth - currentChangeDepth; // Parent change > 0, child change < 0, currentChange == 0\n    let result = [];\n    if (Object(objer__WEBPACK_IMPORTED_MODULE_0__["has"])(listenerObject, \'listeners\')) {\n      for (let listenerdex = 0; listenerdex < listenerObject.listeners.length; listenerdex += 1) {\n        const listener = listenerObject.listeners[listenerdex];\n        if (listener.noChildUpdates === true && changeRelativity > 0) {} // Skip informing parents who don\'t care\n        else if (listener.noParentUpdates === true && changeRelativity < 0) {} // Skip informing children who don\'t care\n          else {\n              result.push({ listener, key });\n            }\n      }\n    }\n\n    if (Object(objer__WEBPACK_IMPORTED_MODULE_0__["has"])(listenerObject, \'subkeys\') && (change instanceof Array || typeof change === \'object\')) {\n      const changeKeys = Object(objer__WEBPACK_IMPORTED_MODULE_0__["keys"])(change);\n      for (let keydex = 0; keydex < changeKeys.length; keydex += 1) {\n        const changeKey = changeKeys[keydex];\n        if (Object(objer__WEBPACK_IMPORTED_MODULE_0__["has"])(listenerObject.subkeys, changeKey)) {\n          result = result.concat(this.recurseMatchingPathsForListeners(change[changeKey], listenerObject.subkeys[changeKey], key.concat(changeKey), originalChangeDepth, currentChangeDepth + 1));\n        }\n      }\n    }\n\n    return result;\n  }\n\n}\nNexustate.defaultSaveCallback = missingCallback;\nNexustate.defaultLoadCallback = missingCallback;\n\n//# sourceURL=webpack://nexusdk/./src/Nexustate.js?')},"./src/NexustateHelpers.js":
/*!*********************************!*\
  !*** ./src/NexustateHelpers.js ***!
  \*********************************/
/*! exports provided: findIndex, throttle, getKeyFilledObject */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "findIndex", function() { return findIndex; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "throttle", function() { return throttle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getKeyFilledObject", function() { return getKeyFilledObject; });\n/* harmony import */ var objer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! objer */ "./node_modules/objer/dist/src/index.js");\n/* harmony import */ var objer__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(objer__WEBPACK_IMPORTED_MODULE_0__);\n\n\nfunction findIndex(array, callback, context) {\n  for (let keydex = 0; keydex < array.length; keydex += 1) {\n    if (callback(array[keydex])) return keydex;\n  }\n  return -1;\n}\n\n// ** COPIED FROM UNDERSCORE JS **\n// Returns a function, that, when invoked, will only be triggered at most once\n// during a given window of time. Normally, the throttled function will run\n// as much as it can, without ever going more than once per `wait` duration;\n// but if you\'d like to disable the execution on the leading edge, pass\n// `{leading: false}`. To disable execution on the trailing edge, ditto.\nfunction throttle(func, wait, options) {\n  var timeout, context, args, result;\n  var previous = 0;\n  if (!options) options = {};\n\n  var later = function () {\n    previous = options.leading === false ? 0 : new Date().getTime();\n    timeout = null;\n    result = func.apply(context, args);\n    if (!timeout) context = args = null;\n  };\n\n  var throttled = function () {\n    var now = new Date().getTime();\n    if (!previous && options.leading === false) previous = now;\n    var remaining = wait - (now - previous);\n    context = this;\n    args = arguments;\n    if (remaining <= 0 || remaining > wait) {\n      if (timeout) {\n        clearTimeout(timeout);\n        timeout = null;\n      }\n      previous = now;\n      result = func.apply(context, args);\n      if (!timeout) context = args = null;\n    } else if (!timeout && options.trailing !== false) {\n      timeout = setTimeout(later, remaining);\n    }\n    return result;\n  };\n\n  throttled.cancel = function () {\n    clearTimeout(timeout);\n    previous = 0;\n    timeout = context = args = null;\n  };\n\n  return throttled;\n}\n\nfunction getKeyFilledObject(key, value) {\n  if (key === null) return value;\n  const result = {};\n  Object(objer__WEBPACK_IMPORTED_MODULE_0__["assurePathExists"])(result, key);\n  Object(objer__WEBPACK_IMPORTED_MODULE_0__["set"])(result, key, value);\n  return result;\n}\n\n//# sourceURL=webpack://nexusdk/./src/NexustateHelpers.js?')},"./src/ShardedNexustate.js":
/*!*********************************!*\
  !*** ./src/ShardedNexustate.js ***!
  \*********************************/
/*! exports provided: default */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ShardedNexustate; });\n/* harmony import */ var _Nexustate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Nexustate */ "./src/Nexustate.js");\n/* harmony import */ var objer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! objer */ "./node_modules/objer/dist/src/index.js");\n/* harmony import */ var objer__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(objer__WEBPACK_IMPORTED_MODULE_1__);\n\n\n\nclass ShardedNexustate {\n  constructor({ saveCallback, loadCallback } = {}) {\n    this.getShard = (shard = \'default\', options) => {\n      if (!this.dataManagerShards[shard]) {\n        const passOptions = Object.assign({ storageKey: shard }, this.defaultOptions || {}, options || {});\n        this.dataManagerShards[shard] = new _Nexustate__WEBPACK_IMPORTED_MODULE_0__["default"](passOptions);\n      }\n      return this.dataManagerShards[shard];\n    };\n\n    this.createShard = (shard, options) => {\n      return this.getShard(shard, options);\n    };\n\n    this.getAllShards = () => {\n      return this.dataManagerShards;\n    };\n\n    this.loadShards = shardList => {\n      (shardList || []).forEach(shard => {\n        const typeString = Object(objer__WEBPACK_IMPORTED_MODULE_1__["getTypeString"])(shard);\n        let loadedShard = null;\n        if (typeString === \'object\') {\n          const { name, options } = shard;\n          loadedShard = this.getShard(name, options);\n        } else if (typeString === \'string\') {\n          loadedShard = this.getShard(shard);\n        }\n\n        if (loadedShard) {\n          loadedShard.load();\n        }\n      });\n    };\n\n    this.dataManagerShards = {};\n    this.defaultOptions = {\n      saveCallback,\n      loadCallback\n    };\n  }\n\n  setAllPersistenceFunctions(saveCallback, loadCallback) {\n    this.defaultOptions.saveCallback = saveCallback;\n    this.defaultOptions.loadCallback = loadCallback;\n    Object(objer__WEBPACK_IMPORTED_MODULE_1__["values"])(this.dataManagerShards).forEach(manager => {\n      manager.setPersistenceFunctions(saveCallback, loadCallback);\n    });\n  }\n\n}\n\n//# sourceURL=webpack://nexusdk/./src/ShardedNexustate.js?')},"./src/StorageManager.js":
/*!*******************************!*\
  !*** ./src/StorageManager.js ***!
  \*******************************/
/*! exports provided: default */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return StorageManager; });\n/* harmony import */ var objer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! objer */ "./node_modules/objer/dist/src/index.js");\n/* harmony import */ var objer__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(objer__WEBPACK_IMPORTED_MODULE_0__);\n\n\nclass StorageManager {\n  constructor() {\n    this.data = {};\n  }\n\n  set(key, value) {\n    if (key === null) this.data = value;\n    if (this.data === null) this.data = {};\n    return Object(objer__WEBPACK_IMPORTED_MODULE_0__["set"])(this.data, key, value);\n  }\n\n  get(key = null) {\n    if (key === null) return this.data;\n    return Object(objer__WEBPACK_IMPORTED_MODULE_0__["get"])(this.data, key);\n  }\n\n  delete(key) {\n    const keyArray = Object(objer__WEBPACK_IMPORTED_MODULE_0__["getObjectPath"])(key);\n    let value = this.data;\n    for (let keydex = 0; keydex < keyArray.length - 1; keydex += 1) {\n      value = value[keyArray[keydex]];\n    }\n    const finalKey = keyArray[keyArray.length - 1];\n    if (value instanceof Array && toString.call(finalKey) === \'[object Number]\') {\n      value.splice(finalKey, 1);\n    } else {\n      delete value[finalKey];\n    }\n  }\n\n  push(key, value) {\n    if (key === null) this.data.push(value);\n    if (this.data === null) this.data = {};\n    Object(objer__WEBPACK_IMPORTED_MODULE_0__["assurePathExists"])(this.data, key, []);\n    this.get(key).push(value);\n  }\n\n  pop(key, value) {\n    if (key === null) this.data.pop(value);\n    if (this.data === null) this.data = {};\n    Object(objer__WEBPACK_IMPORTED_MODULE_0__["get"])(this.data, key).pop(value);\n  }\n\n  unshift(key, value) {\n    if (key === null) this.data.unshift(value);\n    if (this.data === null) this.data = {};\n    Object(objer__WEBPACK_IMPORTED_MODULE_0__["get"])(this.data, key).unshift(value);\n  }\n\n  shift(key, value) {\n    if (key === null) this.data.shift(value);\n    if (this.data === null) this.data = {};\n    Object(objer__WEBPACK_IMPORTED_MODULE_0__["get"])(this.data, key).shift(value);\n  }\n\n  splice(key, index, length) {\n    if (key === null) this.data.splice(index, length);\n    if (this.data === null) this.data = {};\n    Object(objer__WEBPACK_IMPORTED_MODULE_0__["get"])(this.data, key).splice(index, length);\n  }\n}\n\n//# sourceURL=webpack://nexusdk/./src/StorageManager.js?')},"./src/getNexustate.js":
/*!*****************************!*\
  !*** ./src/getNexustate.js ***!
  \*****************************/
/*! exports provided: default */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return getNexustate; });\n/* harmony import */ var _Nexustate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Nexustate */ "./src/Nexustate.js");\n\n\n/**\n * Get global instance of nexustate with a given name, pass options to instantiate with options\n * @param {string} name\n * @param {object} options\n * @param {boolean} options.persist\n */\nfunction getNexustate(name = \'default\', options) {\n  if (getNexustate.managers === undefined) getNexustate.managers = {};\n  if (getNexustate.managers[name] === undefined) {\n    const passOptions = Object.assign({}, { saveCallback: null, loadCallback: null, persist: false, storageKey: name }, options || {});\n    getNexustate.managers[name] = new _Nexustate__WEBPACK_IMPORTED_MODULE_0__["default"](passOptions);\n    if (passOptions.persist) {\n      getNexustate.managers[name].load();\n    }\n  };\n  return getNexustate.managers[name];\n}\n\n//# sourceURL=webpack://nexusdk/./src/getNexustate.js?')},"./src/getShardedNexustate.js":
/*!************************************!*\
  !*** ./src/getShardedNexustate.js ***!
  \************************************/
/*! exports provided: default */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return getShardedNexustate; });\n/* harmony import */ var _ShardedNexustate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ShardedNexustate */ "./src/ShardedNexustate.js");\n\n\nfunction getShardedNexustate() {\n  if (!getShardedNexustate.shardedNexustate) {\n    getShardedNexustate.shardedNexustate = new _ShardedNexustate__WEBPACK_IMPORTED_MODULE_0__["default"]();\n  }\n\n  return getShardedNexustate.shardedNexustate;\n}\n\n//# sourceURL=webpack://nexusdk/./src/getShardedNexustate.js?')},"./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! exports provided: Nexustate, getNexustate, ShardedNexustate, getShardedNexustate */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Nexustate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Nexustate */ "./src/Nexustate.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Nexustate", function() { return _Nexustate__WEBPACK_IMPORTED_MODULE_0__["default"]; });\n\n/* harmony import */ var _getNexustate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getNexustate */ "./src/getNexustate.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getNexustate", function() { return _getNexustate__WEBPACK_IMPORTED_MODULE_1__["default"]; });\n\n/* harmony import */ var _ShardedNexustate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ShardedNexustate */ "./src/ShardedNexustate.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ShardedNexustate", function() { return _ShardedNexustate__WEBPACK_IMPORTED_MODULE_2__["default"]; });\n\n/* harmony import */ var _getShardedNexustate__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getShardedNexustate */ "./src/getShardedNexustate.js");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getShardedNexustate", function() { return _getShardedNexustate__WEBPACK_IMPORTED_MODULE_3__["default"]; });\n\n\n\n\n\n\n\n\n//# sourceURL=webpack://nexusdk/./src/index.js?')}})},module.exports=factory()},function(module,exports,__webpack_require__){var factory;global,factory=function(){return function(e){var n={};function t(r){if(n[r])return n[r].exports;var a=n[r]={i:r,l:!1,exports:{}};return e[r].call(a.exports,a,a.exports,t),a.l=!0,a.exports}return t.m=e,t.c=n,t.d=function(e,n,r){t.o(e,n)||Object.defineProperty(e,n,{configurable:!1,enumerable:!0,get:r})},t.r=function(e){Object.defineProperty(e,"__esModule",{value:!0})},t.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(n,"a",n),n},t.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},t.p="",t.w={},t(t.s="./src/index.js")}({"./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! exports provided: set, keys, values, has, hasRoot, get, yank, getObjectPath, getStringPathForArray, assurePathExists, getTypeString, deepEq, shallowDiff, default */function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"set\", function() { return set; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"keys\", function() { return keys; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"values\", function() { return values; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"has\", function() { return has; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"hasRoot\", function() { return hasRoot; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"get\", function() { return get; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"yank\", function() { return yank; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getObjectPath\", function() { return getObjectPath; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getStringPathForArray\", function() { return getStringPathForArray; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"assurePathExists\", function() { return assurePathExists; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getTypeString\", function() { return getTypeString; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"deepEq\", function() { return deepEq; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"shallowDiff\", function() { return shallowDiff; });\n/**\n * Objer module, interact with objects\n * @module objer\n */\n\n/**\n * Set value at an object subpath\n * @param {Object} object\n * @param {string|array} path\n * @param {*} value\n */\nfunction set(object, path, value) {\n  let subObject = object;\n  const keys = getObjectPath(path);\n  for (let keydex = 0; keydex < keys.length; keydex += 1) {\n    let key = keys[keydex];\n    if (key !== '') {\n      if (keydex !== keys.length - 1) {\n        if (subObject[key] === null || typeof subObject[key] !== 'object') {\n          subObject[key] = {};\n        }\n        subObject = subObject[key];\n      } else {\n        subObject[key] = value;\n      }\n    }\n  }\n\n  return object;\n}\n\n/**\n * Get array of keys in an object\n * @param {Object} object\n */\nfunction keys(object) {\n  const stringType = getTypeString(object);\n  if (stringType === 'object') {\n    if (typeof Object.keys !== 'undefined') return Object.keys(object);\n    const keys = [];\n\n    for(let key in object) {\n      if (object.hasOwnProperty(key)) {\n        keys.push(key);\n      }\n    }\n\n    return keys;\n  }\n  return [];\n}\n\n/**\n * Get array of values in an object, passing an array will return the original array, anything else will return a blank array\n * @param {Object} object\n */\nfunction values(object) {\n  const stringType = getTypeString(object);\n  if (stringType === 'object') {\n    const objectKeys = keys(object);\n    const result = [];\n    for (let keydex = 0; keydex < objectKeys.length; keydex += 1) {\n      result.push(object[objectKeys[keydex]]);\n    }\n    return result;\n  } else if (stringType === 'array') {\n    return object;\n  }\n  return [];\n}\n\n/**\n * Check if an object has a value at a path\n * @param {Object} object\n * @param {string|array} path\n */\nfunction has(object, path) {\n  let subObject = object;\n  const keys = getObjectPath(path);\n  if (keys.length === 0) return false;\n  for (let keydex = 0; keydex < keys.length; keydex += 1) {\n    let key = keys[keydex];\n    if (!hasRoot(subObject, key)) return false;\n    subObject = subObject[key];\n  }\n\n  return true;\n}\n\n/**\n * Check if an object has a top level key, hasRoot({ a: 1 }, 'a'); is true, hasRoot({ a: { b: 1 } }, 'a.b'); is false\n * @param {Object} object\n * @param {string} key\n */\nfunction hasRoot(object, key) {\n  if (object !== null && typeof object === 'object') {\n    return (key in object);\n  }\n  return false;\n}\n\n/**\n * Retrieve value from within an object or array\n * @param {Object} object\n * @param {string|array} path\n * @param {*} [defaultValue]\n */\nfunction get(object, path, defaultValue = undefined) {\n  let subObject = object;\n  const keys = getObjectPath(path);\n  for (let keydex = 0; keydex < keys.length; keydex += 1) {\n    let key = keys[keydex];\n    if (key !== '') {\n      if (!hasRoot(subObject, key)) return defaultValue;\n\n      subObject = subObject[key];\n    }\n  }\n\n  return subObject;\n}\n\n/**\n * Retrieve subobject at path, if the key is null or undefined, the default value or undefined will be returned\n * @param {Object} object\n * @param {string|array} path\n * @param {*} [defaultValue]\n */\nfunction yank(object, path, defaultValue = undefined) {\n  const stringType = getTypeString(path);\n  if (stringType !== 'string' && stringType !== 'array' && stringType !== 'number') return defaultValue;\n  let subObject = object;\n  const keys = getObjectPath(path);\n  for (let keydex = 0; keydex < keys.length; keydex += 1) {\n    let key = keys[keydex];\n    if (key !== '') {\n      if (!hasRoot(subObject, key)) return defaultValue;\n\n      subObject = subObject[key];\n    }\n  }\n\n  return subObject;\n}\n\n/**\n * Resolve a path to a path array 'a.b.c' returns ['a', 'b', 'c']\n * @param {string|array} path\n */\nfunction getObjectPath(path) {\n  const inputType = getTypeString(path);\n  if (inputType === 'array') return path;\n  if (inputType !== 'string') {\n    if (inputType === 'number') return [path];\n    return [];\n  }\n  let inBrackets = false;\n  let partBegin = 0;\n  let split = false;\n  let exitBrackets = false;\n  const pathlen = path.length;\n  const parts = [];\n\n  for(let dex = 0; dex < pathlen + 1; dex += 1) {\n    const char = path[dex];\n    if (inBrackets && !exitBrackets) {\n      if (char === ']') {\n        exitBrackets = true;\n      }\n    } else if (char === '.') {\n      split = true;\n    } else if (char === '[') {\n      split = true;\n      inBrackets = true;\n    }\n\n    if (split || dex === pathlen) {\n      let nextPart = path.substr(partBegin, dex - partBegin - (exitBrackets ? 1 : 0))\n      if (inBrackets) {\n        const parsed = parseInt(nextPart, 10);\n        if (!isNaN(parsed)) {\n          nextPart = parsed;\n        }\n      }\n      parts.push(nextPart);\n      partBegin = dex + 1;\n      split = false;\n      if (exitBrackets) inBrackets = false;\n      exitBrackets = false;\n    }\n  }\n  return parts;\n}\n\n/**\n * Convert an array into a string path ['a', 'b', 'c'] returns 'a.b.c'\n * @param {array} arrayPath\n */\nfunction getStringPathForArray(arrayPath) {\n  const inputType = getTypeString(arrayPath);\n  if (inputType !== 'array') {\n    if (inputType === 'string') return arrayPath;\n    if (inputType === 'number') return `[${arrayPath}]`;\n    return '';\n  }\n\n  return arrayPath.reduce((result, item, dex) => {\n    if (getTypeString(item) === 'number') {\n      return `${result}[${item}]`;\n    }\n    return result + (dex > 0 ? '.': '') + item;\n  }, '');\n}\n\n/**\n * If this subkey doesn't exist, initialize it to defaultValue\n * @param {Object} object\n * @param {string|array} path\n * @param {*} defaultValue\n */\nfunction assurePathExists(object, path, defaultValue = {}) {\n  const arrayPath = getObjectPath(path);\n  let currentObject = object;\n  for (let arraydex = 0; arraydex < arrayPath.length; arraydex += 1) {\n    const key = arrayPath[arraydex];\n    if (!hasRoot(currentObject, key)) { // TODO: Address problems where key exists already and is not an array or object\n      const nextKey = ((arraydex === arrayPath.length - 1) ? null : arrayPath[arraydex + 1]);\n      if (nextKey === null) {\n        currentObject[key] = defaultValue;\n      } else if (getTypeString(nextKey) === 'number') {\n        currentObject[key] = [];\n      } else {\n        currentObject[key] = {};\n      }\n    }\n    currentObject = currentObject[key];\n  }\n  return currentObject;\n}\n\n/**\n * Return simplified type as a string. [] returns 'array' new Date() returns 'date'\n * @param {*} data\n */\nfunction getTypeString(data) {\n  const stringType = typeof data;\n  if (stringType === 'object') {\n    if (data === null) return 'null';\n    const stringified = toString.apply(data);\n    if (stringified.length > 2 && stringified[0] === '[' && stringified[stringified.length - 1] === ']') {\n      const splits = stringified.substr(1, stringified.length - 2).split(' ');\n      if (splits.length > 1) {\n        return splits.slice(1).join(' ').toLowerCase();\n      }\n    }\n    return 'unknown';\n  }\n\n  if (stringType === 'number') {\n    if (isNaN(data)) return 'nan';\n  }\n\n  return stringType;\n}\n\n/**\n * Check if both parameters are equal, check all nested keys of objects and arrays\n * @param {*} obja\n * @param {*} objb\n */\nfunction deepEq(left, right) {\n  const leftType = getTypeString(left);\n  const rightType = getTypeString(right);\n\n  if (leftType !== rightType) return false;\n\n  if (leftType === 'nan') return true;\n\n  if (leftType === 'object') {\n    if (left === right) return true; // if they are the same thing, don't check children\n    const leftKeys = keys(left).sort(); // unsorted could be unequal\n    const rightKeys = keys(right).sort();\n    if (!deepEq(leftKeys, rightKeys)) return false;\n    for (let keydex = 0; keydex < leftKeys.length; keydex += 1) {\n      if (!deepEq(left[leftKeys[keydex]], right[leftKeys[keydex]])) return false;\n    }\n    return true;\n  }\n  if (leftType === 'array') {\n    if (left === right) return true; // if they are the same thing, don't check children\n    if (left.length !== right.length) return false;\n    for (let dex = 0; dex < left.length; dex += 1) {\n      if (!deepEq(left[dex], right[dex])) return false;\n    }\n    return true;\n  }\n\n  return left === right;\n}\n\n/**\n * Detect differences between two things, will indicate changes in type, value, length, etc. Will not diff string values.\n * @param {*} original\n * @param {*} incoming\n */\nfunction shallowDiff(original, incoming, currentPath = []) {\n  let changes = [];\n  const originalType = getTypeString(original);\n  const incomingType = getTypeString(incoming);\n\n  if (originalType !== incomingType) return [{ change: 'type', path: currentPath, original: original, incoming: incoming }];\n\n  if (originalType === 'nan') return [];\n\n  if (originalType === 'object') {\n    if (original === incoming) return []; // if they are the same thing, don't check children\n    let originalKeys = keys(original).sort(); // unsorted could be unequal\n    let incomingKeys = keys(incoming).sort();\n    let sharedKeys = [];\n    if (!deepEq(originalKeys, incomingKeys)) {\n      for (let originalDex = originalKeys.length - 1; originalDex >= 0; originalDex -= 1) {\n        const originalKey = originalKeys[originalDex];\n        for (let incomingDex = incomingKeys.length - 1; incomingDex >= 0; incomingDex -= 1) {\n          if (originalKey === incomingKeys[incomingDex]) {\n            sharedKeys.push(originalKey);\n            originalKeys.splice(originalDex, 1);\n            incomingKeys.splice(incomingDex, 1);\n            break;\n          }\n        }\n      }\n      for (let originalDex = 0; originalDex < originalKeys.length; originalDex += 1) {\n        changes.push({ change: 'delete', path: currentPath, key: originalKeys[originalDex], original: original[originalKeys[originalDex]] });\n      }\n      for (let incomingDex = 0; incomingDex < incomingKeys.length; incomingDex += 1) {\n        changes.push({ change: 'add', path: currentPath, key: incomingKeys[incomingDex], incoming: incoming[incomingKeys[incomingDex]] });\n      }\n    } else {\n      sharedKeys = originalKeys;\n    }\n    for (let keydex = 0; keydex < sharedKeys.length; keydex += 1) {\n      changes = changes.concat(shallowDiff(original[sharedKeys[keydex]], incoming[sharedKeys[keydex]], currentPath.concat(sharedKeys[keydex])));\n    }\n  } else if (originalType === 'array') {\n    if (original === incoming) return []; // if they are the same thing, don't check children\n    let sharedLength = original.length;\n    if (original.length !== incoming.length) {\n      if (original.length > incoming.length) {\n        sharedLength = incoming.length;\n        changes.push({ change: 'shrink', path: currentPath, original: original.slice(incoming.length) });\n      } else {\n        changes.push({ change: 'grow', path: currentPath, incoming: incoming.slice(original.length) });\n      }\n    }\n    for (let dex = 0; dex < sharedLength; dex += 1) {\n      changes = changes.concat(shallowDiff(original[dex], incoming[dex], currentPath.concat(dex)));\n    }\n  } else if (original === incoming) {\n    return [];\n  } else {\n    return [{ change: 'value', path: currentPath, original, incoming }]\n  }\n\n  return changes;\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  assurePathExists,\n  deepEq,\n  get,\n  getObjectPath,\n  getStringPathForArray,\n  getTypeString,\n  has,\n  hasRoot,\n  keys,\n  set,\n  yank,\n});\n\n\n//# sourceURL=webpack://nexusdk/./src/index.js?")}})},module.exports=factory()},function(e,n,t){"use strict";e.exports=t(9)},function(e,n){var t=function(){"use strict";function e(e,n){return null!=n&&e instanceof n}var n,t,r;try{n=Map}catch(e){n=function(){}}try{t=Set}catch(e){t=function(){}}try{r=Promise}catch(e){r=function(){}}function a(i,o,l,c,u){"object"==typeof o&&(l=o.depth,c=o.prototype,u=o.includeNonEnumerable,o=o.circular);var _=[],h=[],d="undefined"!=typeof Buffer;return void 0===o&&(o=!0),void 0===l&&(l=1/0),function i(l,p){if(null===l)return null;if(0===p)return l;var f,y;if("object"!=typeof l)return l;if(e(l,n))f=new n;else if(e(l,t))f=new t;else if(e(l,r))f=new r(function(e,n){l.then(function(n){e(i(n,p-1))},function(e){n(i(e,p-1))})});else if(a.__isArray(l))f=[];else if(a.__isRegExp(l))f=new RegExp(l.source,s(l)),l.lastIndex&&(f.lastIndex=l.lastIndex);else if(a.__isDate(l))f=new Date(l.getTime());else{if(d&&Buffer.isBuffer(l))return f=new Buffer(l.length),l.copy(f),f;e(l,Error)?f=Object.create(l):void 0===c?(y=Object.getPrototypeOf(l),f=Object.create(y)):(f=Object.create(c),y=c)}if(o){var g=_.indexOf(l);if(-1!=g)return h[g];_.push(l),h.push(f)}for(var b in e(l,n)&&l.forEach(function(e,n){var t=i(n,p-1),r=i(e,p-1);f.set(t,r)}),e(l,t)&&l.forEach(function(e){var n=i(e,p-1);f.add(n)}),l){var k;y&&(k=Object.getOwnPropertyDescriptor(y,b)),k&&null==k.set||(f[b]=i(l[b],p-1))}if(Object.getOwnPropertySymbols){var x=Object.getOwnPropertySymbols(l);for(b=0;b<x.length;b++){var m=x[b];(!(O=Object.getOwnPropertyDescriptor(l,m))||O.enumerable||u)&&(f[m]=i(l[m],p-1),O.enumerable||Object.defineProperty(f,m,{enumerable:!1}))}}if(u){var j=Object.getOwnPropertyNames(l);for(b=0;b<j.length;b++){var O,w=j[b];(O=Object.getOwnPropertyDescriptor(l,w))&&O.enumerable||(f[w]=i(l[w],p-1),Object.defineProperty(f,w,{enumerable:!1}))}}return f}(i,l)}function i(e){return Object.prototype.toString.call(e)}function s(e){var n="";return e.global&&(n+="g"),e.ignoreCase&&(n+="i"),e.multiline&&(n+="m"),n}return a.clonePrototype=function(e){if(null===e)return null;var n=function(){};return n.prototype=e,new n},a.__objToStr=i,a.__isDate=function(e){return"object"==typeof e&&"[object Date]"===i(e)},a.__isArray=function(e){return"object"==typeof e&&"[object Array]"===i(e)},a.__isRegExp=function(e){return"object"==typeof e&&"[object RegExp]"===i(e)},a.__getRegExpFlags=s,a}();"object"==typeof e&&e.exports&&(e.exports=t)},function(e,n,t){"use strict";t.r(n);var r=t(0),a=t(2),i=t.n(a),s=t(1),o=t(3),l=t.n(o),c=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r])}return e};function u(e,n,t){return null===n?t:(Object(s.set)(e,n,t),e)}function _(e,n,t){return u(l()(e),n,t)}function h(e,{cloneState:n=!1}={}){const t=n?_:u;return class extends a.Component{constructor(e){super(e),this.createShard=((e,n)=>this.shardState.createShard(e,n)),this.unlisten=((e,{shard:n="default",resetState:t=!1}={})=>{const r=this.shardState.getShard(n).unlisten(e,this.handleChange);return t&&this.setState({data:{}}),r}),this.unlistenFromAll=(({resetState:e=!0}={})=>{const n=Object(s.values)(this.shardState.getAllShards());for(let e=0;e<n.length;e+=1)n[e].unlistenComponent(this);e&&this.setState({data:{}})}),this.setComposedState=((e,n)=>{this.setState({data:t(this.state.data,e,n)})}),this.listenForChange=((e={shard:"default",key:"",alias:null,transform:null,initialLoad:!0,noChildUpdates:!1,noParentUpdates:!1})=>{const n=this.shardState.getShard(e.shard),t=c({},e,{callback:this.handleChange,component:this});if(n.listen(t),e.initialLoad){const e=n.getForListener(t);this.setComposedState(e.alias||e.key,e.value)}}),this.listenForMultiple=((e,{initialLoad:n=!1}={})=>{for(let t=0;t<e.length;t+=1)if(this.listenForChange(e[t]),n){const n=this.shardState.getShard(e[t].shard||"default").getForListener(e[t]);this.setComposedState(n.alias||n.key,n.value)}}),this.handleChange=(e=>{for(let n=0;n<e.length;n+=1){const t=e[n],{alias:r,key:a,value:i}=t;this.setComposedState(r||a,i)}}),this.getData=((e,{shard:n="default"}={})=>this.shardState.getShard(n).get(e)),this.setData=((e,{shard:n="default"}={})=>this.shardState.getShard(n).set(e)),this.deleteData=((e,{shard:n="default"}={})=>this.shardState.getShard(n).delete(e)),this.setKeyData=((e,n,{shard:t="default"}={})=>this.shardState.getShard(t).setKey(e,n)),this.pushData=((e,n,{shard:t="default"}={})=>this.shardState.getShard(t).push(e,n)),this.state={data:{}},this.shardState=Object(r.getShardedNexustate)(),this.nexusFunctions={push:this.pushData,set:this.setData,delete:this.deleteData,setKey:this.setKeyData,listen:this.listenForChange,listenMultiple:this.listenForMultiple,get:this.getData,unlistenAll:this.unlistenFromAll,unlisten:this.unlisten}}componentWillUnmount(){return this.unlistenFromAll({})}render(){return i.a.createElement(e,c({data:this.state.data,nexus:this.nexusFunctions},this.props))}}}t.d(n,"Nexustate",function(){return r.Nexustate}),t.d(n,"getNexustate",function(){return r.getNexustate}),t.d(n,"ShardedNexustate",function(){return r.ShardedNexustate}),t.d(n,"getShardedNexustate",function(){return r.getShardedNexustate}),t.d(n,"withNexustate",function(){return h})},function(e,n,t){"use strict";function r(e){return function(){return e}}var a=function(){};a.thatReturns=r,a.thatReturnsFalse=r(!1),a.thatReturnsTrue=r(!0),a.thatReturnsNull=r(null),a.thatReturnsThis=function(){return this},a.thatReturnsArgument=function(e){return e},e.exports=a},function(e,n,t){"use strict";e.exports={}},function(e,n,t){"use strict";var r=function(e){};e.exports=function(e,n,t,a,i,s,o,l){if(r(n),!e){var c;if(void 0===n)c=new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");else{var u=[t,a,i,s,o,l],_=0;(c=new Error(n.replace(/%s/g,function(){return u[_++]}))).name="Invariant Violation"}throw c.framesToPop=1,c}}},function(e,n,t){"use strict";
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/var r=Object.getOwnPropertySymbols,a=Object.prototype.hasOwnProperty,i=Object.prototype.propertyIsEnumerable;e.exports=function(){try{if(!Object.assign)return!1;var e=new String("abc");if(e[5]="de","5"===Object.getOwnPropertyNames(e)[0])return!1;for(var n={},t=0;t<10;t++)n["_"+String.fromCharCode(t)]=t;if("0123456789"!==Object.getOwnPropertyNames(n).map(function(e){return n[e]}).join(""))return!1;var r={};return"abcdefghijklmnopqrst".split("").forEach(function(e){r[e]=e}),"abcdefghijklmnopqrst"===Object.keys(Object.assign({},r)).join("")}catch(e){return!1}}()?Object.assign:function(e,n){for(var t,s,o=function(e){if(null===e||void 0===e)throw new TypeError("Object.assign cannot be called with null or undefined");return Object(e)}(e),l=1;l<arguments.length;l++){for(var c in t=Object(arguments[l]))a.call(t,c)&&(o[c]=t[c]);if(r){s=r(t);for(var u=0;u<s.length;u++)i.call(t,s[u])&&(o[s[u]]=t[s[u]])}}return o}},function(e,n,t){"use strict";
/** @license React v16.4.1
 * react.production.min.js
 *
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var r=t(8),a=t(7),i=t(6),s=t(5),o="function"==typeof Symbol&&Symbol.for,l=o?Symbol.for("react.element"):60103,c=o?Symbol.for("react.portal"):60106,u=o?Symbol.for("react.fragment"):60107,_=o?Symbol.for("react.strict_mode"):60108,h=o?Symbol.for("react.profiler"):60114,d=o?Symbol.for("react.provider"):60109,p=o?Symbol.for("react.context"):60110,f=o?Symbol.for("react.async_mode"):60111,y=o?Symbol.for("react.forward_ref"):60112;o&&Symbol.for("react.timeout");var g="function"==typeof Symbol&&Symbol.iterator;function b(e){for(var n=arguments.length-1,t="https://reactjs.org/docs/error-decoder.html?invariant="+e,r=0;r<n;r++)t+="&args[]="+encodeURIComponent(arguments[r+1]);a(!1,"Minified React error #"+e+"; visit %s for the full message or use the non-minified dev environment for full errors and additional helpful warnings. ",t)}var k={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}};function x(e,n,t){this.props=e,this.context=n,this.refs=i,this.updater=t||k}function m(){}function j(e,n,t){this.props=e,this.context=n,this.refs=i,this.updater=t||k}x.prototype.isReactComponent={},x.prototype.setState=function(e,n){"object"!=typeof e&&"function"!=typeof e&&null!=e&&b("85"),this.updater.enqueueSetState(this,e,n,"setState")},x.prototype.forceUpdate=function(e){this.updater.enqueueForceUpdate(this,e,"forceUpdate")},m.prototype=x.prototype;var O=j.prototype=new m;O.constructor=j,r(O,x.prototype),O.isPureReactComponent=!0;var w={current:null},P=Object.prototype.hasOwnProperty,v={key:!0,ref:!0,__self:!0,__source:!0};function E(e,n,t){var r=void 0,a={},i=null,s=null;if(null!=n)for(r in void 0!==n.ref&&(s=n.ref),void 0!==n.key&&(i=""+n.key),n)P.call(n,r)&&!v.hasOwnProperty(r)&&(a[r]=n[r]);var o=arguments.length-2;if(1===o)a.children=t;else if(1<o){for(var c=Array(o),u=0;u<o;u++)c[u]=arguments[u+2];a.children=c}if(e&&e.defaultProps)for(r in o=e.defaultProps)void 0===a[r]&&(a[r]=o[r]);return{$$typeof:l,type:e,key:i,ref:s,props:a,_owner:w.current}}function S(e){return"object"==typeof e&&null!==e&&e.$$typeof===l}var D=/\/+/g,T=[];function K(e,n,t,r){if(T.length){var a=T.pop();return a.result=e,a.keyPrefix=n,a.func=t,a.context=r,a.count=0,a}return{result:e,keyPrefix:n,func:t,context:r,count:0}}function M(e){e.result=null,e.keyPrefix=null,e.func=null,e.context=null,e.count=0,10>T.length&&T.push(e)}function C(e,n,t,r){var a=typeof e;"undefined"!==a&&"boolean"!==a||(e=null);var i=!1;if(null===e)i=!0;else switch(a){case"string":case"number":i=!0;break;case"object":switch(e.$$typeof){case l:case c:i=!0}}if(i)return t(r,e,""===n?"."+R(e,0):n),1;if(i=0,n=""===n?".":n+":",Array.isArray(e))for(var s=0;s<e.length;s++){var o=n+R(a=e[s],s);i+=C(a,o,t,r)}else if(null===e||void 0===e?o=null:o="function"==typeof(o=g&&e[g]||e["@@iterator"])?o:null,"function"==typeof o)for(e=o.call(e),s=0;!(a=e.next()).done;)i+=C(a=a.value,o=n+R(a,s++),t,r);else"object"===a&&b("31","[object Object]"===(t=""+e)?"object with keys {"+Object.keys(e).join(", ")+"}":t,"");return i}function R(e,n){return"object"==typeof e&&null!==e&&null!=e.key?function(e){var n={"=":"=0",":":"=2"};return"$"+(""+e).replace(/[=:]/g,function(e){return n[e]})}(e.key):n.toString(36)}function L(e,n){e.func.call(e.context,n,e.count++)}function q(e,n,t){var r=e.result,a=e.keyPrefix;e=e.func.call(e.context,n,e.count++),Array.isArray(e)?N(e,r,t,s.thatReturnsArgument):null!=e&&(S(e)&&(n=a+(!e.key||n&&n.key===e.key?"":(""+e.key).replace(D,"$&/")+"/")+t,e={$$typeof:l,type:e.type,key:n,ref:e.ref,props:e.props,_owner:e._owner}),r.push(e))}function N(e,n,t,r,a){var i="";null!=t&&(i=(""+t).replace(D,"$&/")+"/"),n=K(n,i,r,a),null==e||C(e,"",q,n),M(n)}var A={Children:{map:function(e,n,t){if(null==e)return e;var r=[];return N(e,r,null,n,t),r},forEach:function(e,n,t){if(null==e)return e;n=K(null,null,n,t),null==e||C(e,"",L,n),M(n)},count:function(e){return null==e?0:C(e,"",s.thatReturnsNull,null)},toArray:function(e){var n=[];return N(e,n,null,s.thatReturnsArgument),n},only:function(e){return S(e)||b("143"),e}},createRef:function(){return{current:null}},Component:x,PureComponent:j,createContext:function(e,n){return void 0===n&&(n=null),(e={$$typeof:p,_calculateChangedBits:n,_defaultValue:e,_currentValue:e,_currentValue2:e,_changedBits:0,_changedBits2:0,Provider:null,Consumer:null}).Provider={$$typeof:d,_context:e},e.Consumer=e},forwardRef:function(e){return{$$typeof:y,render:e}},Fragment:u,StrictMode:_,unstable_AsyncMode:f,unstable_Profiler:h,createElement:E,cloneElement:function(e,n,t){(null===e||void 0===e)&&b("267",e);var a=void 0,i=r({},e.props),s=e.key,o=e.ref,c=e._owner;if(null!=n){void 0!==n.ref&&(o=n.ref,c=w.current),void 0!==n.key&&(s=""+n.key);var u=void 0;for(a in e.type&&e.type.defaultProps&&(u=e.type.defaultProps),n)P.call(n,a)&&!v.hasOwnProperty(a)&&(i[a]=void 0===n[a]&&void 0!==u?u[a]:n[a])}if(1===(a=arguments.length-2))i.children=t;else if(1<a){u=Array(a);for(var _=0;_<a;_++)u[_]=arguments[_+2];i.children=u}return{$$typeof:l,type:e.type,key:s,ref:o,props:i,_owner:c}},createFactory:function(e){var n=E.bind(null,e);return n.type=e,n},isValidElement:S,version:"16.4.1",__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED:{ReactCurrentOwner:w,assign:r}},B={default:A},I=B&&A||B;e.exports=I.default?I.default:I}])});